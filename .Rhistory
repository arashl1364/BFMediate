SimMeasurementYCat = function(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde){
nobs = dim(X)[1]
y_star = y_tilde = matrix(double(nobs*Y_ind), ncol = Y_ind)
M = cbind(rep(1,nobs),X)%*%beta_1 + rnorm(nobs)
Y = cbind(rep(1,nobs),cbind(M,X))%*%beta_2 + rnorm(nobs)
for(i in 1: Y_ind){
y_tilde[,i] = beta_y_tilde[i] + Y + sqrt(ssq_y_tilde[i])*rnorm(nobs);
y_star[,i] = cut(y_tilde[,i], br = cutoff_Y[i,], right=TRUE, include.lowest = TRUE, labels = FALSE)
}
return(list(Y = Y, M = M, y_star = y_star, X = X,
beta_1 = beta_1,
k_Y=dim(cutoff_Y)[2]-1, beta_2 = beta_2, beta_y_tilde = beta_y_tilde, ssq_y_tilde = ssq_y_tilde, y_tilde = y_tilde, cutoff_Y = cutoff_Y,
Y_ind=Y_ind,
dstar_Y=dstar_Y))
}
Y_ind = 2
Ycut = 8
nobs=1000
X=as.matrix(runif(nobs,min=0, max=1))
beta_1 = c(.5,1)   # beta_1 = c(-1, 3)
beta_2 = c(1, 4, 2)
ssq_y_tilde = c(.5,1)#,1.5,1,1,.5)
beta_y_tilde = c(0,-.5)#,0,-.5,0,-.5)
# ssq_y_tilde = c(.5)
# beta_y_tilde = c(0)   #the intercepts for the latent Y indicators w. measurement error
# dstar_M = matrix(rep(c(3, 3.5, 4, 4.5, 6) ,M_ind),ncol= Mcut-3, byrow = T)
dstar_Y = matrix(c( .5, -1, -2, .2, 1,
0, 0, 0, 0, 0) ,ncol= Ycut-3, byrow = T)
cutoff_Y = matrix(double(Y_ind*Ycut),ncol=Ycut)
for(i in 1:Y_ind) cutoff_Y[i,] = dstartoc(dstar_Y[i,])
# cutoff_M = matrix(c(-100, 0, 3, 3.5, 4, 4.5, 6, 100,
#                     -100, 0, 1, 2.5, 3, 3.5, 5, 100) ,ncol= Mcut, byrow = T)
# cutoff_Y = matrix(rep(c(-100, 0, 3, 3.5, 4, 4.5, 6, 100) ,Y_ind),ncol= Ycut, byrow = T)
Data = SimMeasurementYCat(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde)
cutoff_Y
SimMeasurementYCat = function(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde){
nobs = dim(X)[1]
y_star = y_tilde = matrix(double(nobs*Y_ind), ncol = Y_ind)
M = cbind(rep(1,nobs),X)%*%beta_1 + rnorm(nobs)
Y = cbind(rep(1,nobs),cbind(M,X))%*%beta_2 + rnorm(nobs)
for(i in 1: Y_ind){
y_tilde[,i] = beta_y_tilde[i] + Y + sqrt(ssq_y_tilde[i])*rnorm(nobs);
y_star[,i] = cut(y_tilde[,i], br = cutoff_Y[i,], right=TRUE, include.lowest = TRUE, labels = FALSE)
}
return(list(Y = Y, M = M, y_star = y_star, X = X,
beta_1 = beta_1,
k_Y=dim(cutoff_Y)[2]-1, beta_2 = beta_2, beta_y_tilde = beta_y_tilde, ssq_y_tilde = ssq_y_tilde, y_tilde = y_tilde, cutoff_Y = cutoff_Y,
Y_ind=Y_ind,
dstar_Y=dstar_Y))
}
Y_ind = 2
Ycut = 8
nobs=1000
X=as.matrix(runif(nobs,min=0, max=1))
beta_1 = c(.5,1)   # beta_1 = c(-1, 3)
beta_2 = c(1, 4, 2)
ssq_y_tilde = c(.5,1)#,1.5,1,1,.5)
beta_y_tilde = c(0,-.5)#,0,-.5,0,-.5)
cutoff_Y =  matrix(c(-100, 0, 1.6, 2, 2.2, 3.3, 6,  100,
-100, 0, 1, 2, 3, 4, 5, 100) ,ncol= Ycut, byrow = T)
Data = SimMeasurementYCat(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde)
#estimation
Ycut = max(as.matrix(Data$y_star)[,1]) +1
DataMeasurementYCat = list(X=cbind(rep(1,length(Data$X)),Data$M,Data$X), y = as.matrix(Data$y_star) ,k=Ycut-1, Y_ind=dim(as.matrix(Data$y_star))[2])
Mcmc=list(R=R)
outMeasurementYCat = MeasurementYCat(Data=DataMeasurementYCat, Mcmc=Mcmc)
#results
colMeans(outMeasurementYCat$betadraw)
apply(outMeasurementYCat$cutdraw,c(1,2),FUN = mean)
SimMeasurementMYCat = function(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde){
nobs = dim(X)[1]
m_star = m_tilde = matrix(double(nobs*M_ind), ncol = M_ind)
y_star = y_tilde = matrix(double(nobs*Y_ind), ncol = Y_ind)
M = cbind(rep(1,nobs),X)%*%beta_1 + rnorm(nobs)
for(i in 1: M_ind){
m_tilde[,i] = beta_m_tilde[i] + M + sqrt(ssq_m_tilde[i])*rnorm(nobs);
m_star[,i] = cut(m_tilde[,i], br = cutoff_M[i,], right=TRUE, include.lowest = TRUE, labels = FALSE)
}
Y = cbind(rep(1,nobs),cbind(M,X))%*%beta_2 + rnorm(nobs)
for(i in 1: Y_ind){
y_tilde[,i] = beta_y_tilde[i] + Y + sqrt(ssq_y_tilde[i])*rnorm(nobs);
y_star[,i] = cut(y_tilde[,i], br = cutoff_Y[i,], right=TRUE, include.lowest = TRUE, labels = FALSE)
}
return(list(Y = Y, M = M, y_star = y_star, m_star = m_star, X = X,
k_M=dim(cutoff_M)[2]-1, beta_1 = beta_1, beta_m_tilde = beta_m_tilde, ssq_m_tilde = ssq_m_tilde, m_tilde = m_tilde, cutoff_M = cutoff_M,
k_Y=dim(cutoff_Y)[2]-1, beta_2 = beta_2, beta_y_tilde = beta_y_tilde, ssq_y_tilde = ssq_y_tilde, y_tilde = y_tilde, cutoff_Y = cutoff_Y,
M_ind=M_ind, Y_ind=Y_ind))
}
M_ind = 6
Y_ind = 2
Mcut = Ycut = 8
nobs=1000
X=as.matrix(runif(nobs,min=0, max=1))
beta_1 = c(.5,1)   # beta_1 = c(-1, 3)
beta_2 = c(1, 2, 0)
ssq_m_tilde = c(.5,1) #,1.5,1,1,.5)
beta_m_tilde = c(0,-.5) #,0,-.5,0,-.5)    #the intercepts for the latent M indicators w. measurement error
ssq_y_tilde = c(.5,1)
beta_y_tilde = c(0,-.5)
cutoff_M = matrix(c(-100, 0, 1.6, 2, 2.2, 3.3, 6,  100,
-100, 0, 1, 2, 3, 4, 5, 100) ,ncol= Mcut, byrow = T)
cutoff_Y =  matrix(c(-100, 0, 1.6, 2, 2.2, 3.3, 6,  100,
-100, 0, 1, 2, 3, 4, 5, 100) ,ncol= Ycut, byrow = T)
Data = SimMeasurementMYCat(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, dstar_M, dstar_Y, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde)
#estimation
Mcut = max(Data$m_star) + 1
Ycut = max(Data$y_star) + 1
DataMeasurementMYCat = list(X=cbind(rep(1,length(Data$X)),Data$X), m_star=as.matrix(Data$m_star),
y_star=as.matrix(Data$y_star), k_M = Mcut-1, k_Y=Ycut-1,
M_ind=dim(as.matrix(Data$m_star))[2], Y_ind=dim(as.matrix(Data$y_star))[2])
Mcmc = list(R=10000)
Data = SimMeasurementMYCat(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde)
SimMeasurementMYCat = function(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde){
nobs = dim(X)[1]
m_star = m_tilde = matrix(double(nobs*M_ind), ncol = M_ind)
y_star = y_tilde = matrix(double(nobs*Y_ind), ncol = Y_ind)
M = cbind(rep(1,nobs),X)%*%beta_1 + rnorm(nobs)
for(i in 1: M_ind){
m_tilde[,i] = beta_m_tilde[i] + M + sqrt(ssq_m_tilde[i])*rnorm(nobs);
m_star[,i] = cut(m_tilde[,i], br = cutoff_M[i,], right=TRUE, include.lowest = TRUE, labels = FALSE)
}
Y = cbind(rep(1,nobs),cbind(M,X))%*%beta_2 + rnorm(nobs)
for(i in 1: Y_ind){
y_tilde[,i] = beta_y_tilde[i] + Y + sqrt(ssq_y_tilde[i])*rnorm(nobs);
y_star[,i] = cut(y_tilde[,i], br = cutoff_Y[i,], right=TRUE, include.lowest = TRUE, labels = FALSE)
}
return(list(Y = Y, M = M, y_star = y_star, m_star = m_star, X = X,
k_M=dim(cutoff_M)[2]-1, beta_1 = beta_1, beta_m_tilde = beta_m_tilde, ssq_m_tilde = ssq_m_tilde, m_tilde = m_tilde, cutoff_M = cutoff_M,
k_Y=dim(cutoff_Y)[2]-1, beta_2 = beta_2, beta_y_tilde = beta_y_tilde, ssq_y_tilde = ssq_y_tilde, y_tilde = y_tilde, cutoff_Y = cutoff_Y,
M_ind=M_ind, Y_ind=Y_ind))
}
M_ind = 6
Y_ind = 2
Mcut = Ycut = 8
nobs=1000
X=as.matrix(runif(nobs,min=0, max=1))
beta_1 = c(.5,1)   # beta_1 = c(-1, 3)
beta_2 = c(1, 2, 0)
ssq_m_tilde = c(.5,1) #,1.5,1,1,.5)
beta_m_tilde = c(0,-.5) #,0,-.5,0,-.5)    #the intercepts for the latent M indicators w. measurement error
ssq_y_tilde = c(.5,1)
beta_y_tilde = c(0,-.5)
cutoff_M = matrix(c(-100, 0, 1.6, 2, 2.2, 3.3, 6,  100,
-100, 0, 1, 2, 3, 4, 5, 100) ,ncol= Mcut, byrow = T)
cutoff_Y =  matrix(c(-100, 0, 1.6, 2, 2.2, 3.3, 6,  100,
-100, 0, 1, 2, 3, 4, 5, 100) ,ncol= Ycut, byrow = T)
Data = SimMeasurementMYCat(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde)
M_ind = 2
Y_ind = 2
Mcut = Ycut = 8
nobs=1000
X=as.matrix(runif(nobs,min=0, max=1))
beta_1 = c(.5,1)   # beta_1 = c(-1, 3)
beta_2 = c(1, 2, 0)
ssq_m_tilde = c(.5,1) #,1.5,1,1,.5)
beta_m_tilde = c(0,-.5) #,0,-.5,0,-.5)    #the intercepts for the latent M indicators w. measurement error
ssq_y_tilde = c(.5,1)
beta_y_tilde = c(0,-.5)
cutoff_M = matrix(c(-100, 0, 1.6, 2, 2.2, 3.3, 6,  100,
-100, 0, 1, 2, 3, 4, 5, 100) ,ncol= Mcut, byrow = T)
cutoff_Y =  matrix(c(-100, 0, 1.6, 2, 2.2, 3.3, 6,  100,
-100, 0, 1, 2, 3, 4, 5, 100) ,ncol= Ycut, byrow = T)
Data = SimMeasurementMYCat(X, beta_1, cutoff_M, beta_2, cutoff_Y, M_ind, Y_ind, beta_m_tilde, beta_y_tilde, ssq_m_tilde, ssq_y_tilde)
#estimation
Mcut = max(Data$m_star) + 1
Ycut = max(Data$y_star) + 1
DataMeasurementMYCat = list(X=cbind(rep(1,length(Data$X)),Data$X), m_star=as.matrix(Data$m_star),
y_star=as.matrix(Data$y_star), k_M = Mcut-1, k_Y=Ycut-1,
M_ind=dim(as.matrix(Data$m_star))[2], Y_ind=dim(as.matrix(Data$y_star))[2])
Mcmc = list(R=10000)
outMeasurementMYCat = MeasurementMYCat(Data=DataMeasurementMYCat, Mcmc=Mcmc)
#results
colMeans(outMeasurementMYCat$betadraw)
colMeans(outMeasurementMYCat$beta_2_draw)
apply(outMeasurementMYCat$cutdraw_M,c(1,2),FUN = mean)
apply(outMeasurementMYCat$cutdraw_Y,c(1,2),FUN = mean)
SimMeasurementCont = function( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, N, X) {
m_star = matrix(double(N*m_ind),ncol = m_ind); y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_m_star = matrix(double(N*m_ind),ncol = m_ind); eps_y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_M = rnorm(N)*sigma_M # generate errors for M (independent)
eps_Y = rnorm(N)*sigma_y # generate errors for y (independent)
M = beta_1[1] + X*beta_1[2]  + eps_M # generate latent mediator M
y = beta_2[1] +  M*beta_2[2] + X*beta_2[3] + eps_Y # generate dependent variable
eps_m_star[,1]=rnorm(N)*sigma_m_star[1] # generate errors for m_star (independent)
m_star[,1] =  M + eps_m_star[,1] # generate observed mediator indicators m_star
if(m_ind>1){
for(i in 2:(m_ind))   {
eps_m_star[,i]=rnorm(N)*sigma_m_star[i] # generate errors for m_star (independent)
m_star[,i] =  lambda[(i-1),1] + M%*%lambda[(i-1),2] + X%*%beta_2[-c(1,2)] + eps_m_star[,i]
}
}
eps_y_star[,1]=rnorm(N)*sigma_y_star[1] # generate errors for y_star (independent)
y_star[,1] =  y + eps_y_star[,1] # generate observed dependent variable indicators y_star
if(y_ind>1){
for(i in 2:(y_ind)){
eps_y_star[,i]=rnorm(N)*sigma_y_star[i] # generate errors for y_star (independent)
y_star[,i] =  tau[(i-1),1] + y%*%tau[(i-1),2] + eps_y_star[,i]
}
}
list(X = X, M = M, m_star = m_star, y = y, y_star=y_star)
}
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(1,2)^.5
sigma_y_star = c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
X = as.matrix(runif(nobs)) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, nobs, X)
nobs = 1000   # number of observations
R = 2000; burnin = 1500
A_M=rep(100,2);
A_Y=c(100,100,10)
SimMeasurementCont = function( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, N, X) {
m_star = matrix(double(N*m_ind),ncol = m_ind); y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_m_star = matrix(double(N*m_ind),ncol = m_ind); eps_y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_M = rnorm(N)*sigma_M # generate errors for M (independent)
eps_Y = rnorm(N)*sigma_y # generate errors for y (independent)
M = beta_1[1] + X*beta_1[2]  + eps_M # generate latent mediator M
y = beta_2[1] +  M*beta_2[2] + X*beta_2[3] + eps_Y # generate dependent variable
eps_m_star[,1]=rnorm(N)*sigma_m_star[1] # generate errors for m_star (independent)
m_star[,1] =  M + eps_m_star[,1] # generate observed mediator indicators m_star
if(m_ind>1){
for(i in 2:(m_ind))   {
eps_m_star[,i]=rnorm(N)*sigma_m_star[i] # generate errors for m_star (independent)
m_star[,i] =  lambda[(i-1),1] + M%*%lambda[(i-1),2] + X%*%beta_2[-c(1,2)] + eps_m_star[,i]
}
}
eps_y_star[,1]=rnorm(N)*sigma_y_star[1] # generate errors for y_star (independent)
y_star[,1] =  y + eps_y_star[,1] # generate observed dependent variable indicators y_star
if(y_ind>1){
for(i in 2:(y_ind)){
eps_y_star[,i]=rnorm(N)*sigma_y_star[i] # generate errors for y_star (independent)
y_star[,i] =  tau[(i-1),1] + y%*%tau[(i-1),2] + eps_y_star[,i]
}
}
list(X = X, M = M, m_star = m_star, y = y, y_star=y_star)
}
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(1,2)^.5
sigma_y_star = c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
X = as.matrix(runif(nobs)) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, nobs, X)
nobs = 1000   # number of observations
R = 2000; burnin = 1500
A_M=rep(100,2);
A_Y=c(100,100,10)
library(BFMediate)
SimMeasurementCont = function( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, N, X) {
m_star = matrix(double(N*m_ind),ncol = m_ind); y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_m_star = matrix(double(N*m_ind),ncol = m_ind); eps_y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_M = rnorm(N)*sigma_M # generate errors for M (independent)
eps_Y = rnorm(N)*sigma_y # generate errors for y (independent)
M = beta_1[1] + X*beta_1[2]  + eps_M # generate latent mediator M
y = beta_2[1] +  M*beta_2[2] + X*beta_2[3] + eps_Y # generate dependent variable
eps_m_star[,1]=rnorm(N)*sigma_m_star[1] # generate errors for m_star (independent)
m_star[,1] =  M + eps_m_star[,1] # generate observed mediator indicators m_star
if(m_ind>1){
for(i in 2:(m_ind))   {
eps_m_star[,i]=rnorm(N)*sigma_m_star[i] # generate errors for m_star (independent)
m_star[,i] =  lambda[(i-1),1] + M%*%lambda[(i-1),2] + X%*%beta_2[-c(1,2)] + eps_m_star[,i]
}
}
eps_y_star[,1]=rnorm(N)*sigma_y_star[1] # generate errors for y_star (independent)
y_star[,1] =  y + eps_y_star[,1] # generate observed dependent variable indicators y_star
if(y_ind>1){
for(i in 2:(y_ind)){
eps_y_star[,i]=rnorm(N)*sigma_y_star[i] # generate errors for y_star (independent)
y_star[,i] =  tau[(i-1),1] + y%*%tau[(i-1),2] + eps_y_star[,i]
}
}
list(X = X, M = M, m_star = m_star, y = y, y_star=y_star)
}
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(1,2)^.5
sigma_y_star = c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
X = as.matrix(runif(nobs)) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, nobs, X)
nobs = 1000   # number of observations
R = 2000; burnin = 1500
A_M=rep(100,2);
A_Y=c(100,100,10)
OutMeasurementCont = Measurement_Cont(Data = Data, BF = list(R = 5000, burnin = 3000, A_M = A_M, A_Y = A_Y))
library(BFMediate)
OutMeasurementCont = Measurement_Cont(Data = Data, BF = list(R = 5000, burnin = 3000, A_M = A_M, A_Y = A_Y))
library(rstan)
OutMeasurementCont = Measurement_Cont(Data = Data, BF = list(R = 5000, burnin = 3000, A_M = A_M, A_Y = A_Y))
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(1,2)^.5
sigma_y_star = c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
X = runif(nobs) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, nobs, X)
nobs = 1000   # number of observations
R = 2000; burnin = 1500
A_M=rep(100,2);
A_Y=c(100,100,10)
OutMeasurementCont = Measurement_Cont(Data = Data, BF = list(R = 5000, burnin = 3000, A_M = A_M, A_Y = A_Y))
dim(X)
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(1,2)^.5
sigma_y_star = c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
X = runif(nobs) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, nobs, X)
nobs = 1000   # number of observations
R = 2000; burnin = 1500
A_M=rep(100,2);
A_Y=c(100,100,10)
OutMeasurementCont = Measurement_Cont(Data = Data, BF = list(R = 5000, burnin = 3000, A_M = A_M, A_Y = A_Y))
dim(Data$X)
SimMeasurementCont = function( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, N, X) {
m_star = matrix(double(N*m_ind),ncol = m_ind); y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_m_star = matrix(double(N*m_ind),ncol = m_ind); eps_y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_M = rnorm(N)*sigma_M # generate errors for M (independent)
eps_Y = rnorm(N)*sigma_y # generate errors for y (independent)
M = beta_1[1] + X*beta_1[2]  + eps_M # generate latent mediator M
y = beta_2[1] +  M*beta_2[2] + X*beta_2[3] + eps_Y # generate dependent variable
eps_m_star[,1]=rnorm(N)*sigma_m_star[1] # generate errors for m_star (independent)
m_star[,1] =  M + eps_m_star[,1] # generate observed mediator indicators m_star
if(m_ind>1){
for(i in 2:(m_ind))   {
eps_m_star[,i]=rnorm(N)*sigma_m_star[i] # generate errors for m_star (independent)
m_star[,i] =  lambda[(i-1),1] + M%*%lambda[(i-1),2] + X%*%beta_2[-c(1,2)] + eps_m_star[,i]
}
}
eps_y_star[,1]=rnorm(N)*sigma_y_star[1] # generate errors for y_star (independent)
y_star[,1] =  y + eps_y_star[,1] # generate observed dependent variable indicators y_star
if(y_ind>1){
for(i in 2:(y_ind)){
eps_y_star[,i]=rnorm(N)*sigma_y_star[i] # generate errors for y_star (independent)
y_star[,i] =  tau[(i-1),1] + y%*%tau[(i-1),2] + eps_y_star[,i]
}
}
list(X = X, M = M, m_star = m_star, y = y, y_star=y_star)
}
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(1,2)^.5
sigma_y_star = c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
X = runif(nobs) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, nobs, X)
nobs = 1000   # number of observations
R = 2000; burnin = 1500
A_M=rep(100,2);
A_Y=c(100,100,10)
SimMeasurementCont = function( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, N, X) {
m_star = matrix(double(N*m_ind),ncol = m_ind); y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_m_star = matrix(double(N*m_ind),ncol = m_ind); eps_y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_M = rnorm(N)*sigma_M # generate errors for M (independent)
eps_Y = rnorm(N)*sigma_y # generate errors for y (independent)
M = beta_1[1] + X*beta_1[2]  + eps_M # generate latent mediator M
y = beta_2[1] +  M*beta_2[2] + X*beta_2[3] + eps_Y # generate dependent variable
eps_m_star[,1]=rnorm(N)*sigma_m_star[1] # generate errors for m_star (independent)
m_star[,1] =  M + eps_m_star[,1] # generate observed mediator indicators m_star
if(m_ind>1){
for(i in 2:(m_ind))   {
eps_m_star[,i]=rnorm(N)*sigma_m_star[i] # generate errors for m_star (independent)
m_star[,i] =  lambda[(i-1),1] + M%*%lambda[(i-1),2] + X%*%beta_2[-c(1,2)] + eps_m_star[,i]
}
}
eps_y_star[,1]=rnorm(N)*sigma_y_star[1] # generate errors for y_star (independent)
y_star[,1] =  y + eps_y_star[,1] # generate observed dependent variable indicators y_star
if(y_ind>1){
for(i in 2:(y_ind)){
eps_y_star[,i]=rnorm(N)*sigma_y_star[i] # generate errors for y_star (independent)
y_star[,i] =  tau[(i-1),1] + y%*%tau[(i-1),2] + eps_y_star[,i]
}
}
list(X = X, M = M, m_star = m_star, y = y, y_star=y_star)
}
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(1,2)^.5
sigma_y_star = c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
X = runif(nobs) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, nobs, X)
nobs = 1000   # number of observations
R = 2000; burnin = 1500
A_M=rep(100,2);
A_Y=c(100,100,10)
beta_2[-c(1,2)]
lambda[(i-1),2]
SimMeasurementCont = function( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, N, X) {
m_star = matrix(double(N*m_ind),ncol = m_ind); y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_m_star = matrix(double(N*m_ind),ncol = m_ind); eps_y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_M = rnorm(N)*sigma_M # generate errors for M (independent)
eps_Y = rnorm(N)*sigma_y # generate errors for y (independent)
M = beta_1[1] + X*beta_1[2]  + eps_M # generate latent mediator M
y = beta_2[1] +  M*beta_2[2] + X*beta_2[3] + eps_Y # generate dependent variable
eps_m_star[,1]=rnorm(N)*sigma_m_star[1] # generate errors for m_star (independent)
m_star[,1] =  M + eps_m_star[,1] # generate observed mediator indicators m_star
if(m_ind>1){
for(i in 2:(m_ind))   {
eps_m_star[,i]=rnorm(N)*sigma_m_star[i] # generate errors for m_star (independent)
m_star[,i] =  lambda[(i-1),1] + M*lambda[(i-1),2] + X*beta_2[-c(1,2)] + eps_m_star[,i]
}
}
eps_y_star[,1]=rnorm(N)*sigma_y_star[1] # generate errors for y_star (independent)
y_star[,1] =  y + eps_y_star[,1] # generate observed dependent variable indicators y_star
if(y_ind>1){
for(i in 2:(y_ind)){
eps_y_star[,i]=rnorm(N)*sigma_y_star[i] # generate errors for y_star (independent)
y_star[,i] =  tau[(i-1),1] + y%*%tau[(i-1),2] + eps_y_star[,i]
}
}
list(X = X, M = M, m_star = m_star, y = y, y_star=y_star)
}
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(1,2)^.5
sigma_y_star = c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
X = runif(nobs) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, nobs, X)
nobs = 1000   # number of observations
R = 2000; burnin = 1500
A_M=rep(100,2);
A_Y=c(100,100,10)
################################################
SimMeasurementCont = function( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, N, X) {
m_star = matrix(double(N*m_ind),ncol = m_ind); y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_m_star = matrix(double(N*m_ind),ncol = m_ind); eps_y_star = matrix(double(N*y_ind),ncol = y_ind)
eps_M = rnorm(N)*sigma_M # generate errors for M (independent)
eps_Y = rnorm(N)*sigma_y # generate errors for y (independent)
M = beta_1[1] + X*beta_1[2]  + eps_M # generate latent mediator M
y = beta_2[1] +  M*beta_2[2] + X*beta_2[3] + eps_Y # generate dependent variable
eps_m_star[,1]=rnorm(N)*sigma_m_star[1] # generate errors for m_star (independent)
m_star[,1] =  M + eps_m_star[,1] # generate observed mediator indicators m_star
if(m_ind>1){
for(i in 2:(m_ind))   {
eps_m_star[,i]=rnorm(N)*sigma_m_star[i] # generate errors for m_star (independent)
m_star[,i] =  lambda[(i-1),1] + M*lambda[(i-1),2] + X*beta_2[-c(1,2)] + eps_m_star[,i]
}
}
eps_y_star[,1]=rnorm(N)*sigma_y_star[1] # generate errors for y_star (independent)
y_star[,1] =  y + eps_y_star[,1] # generate observed dependent variable indicators y_star
if(y_ind>1){
for(i in 2:(y_ind)){
eps_y_star[,i]=rnorm(N)*sigma_y_star[i] # generate errors for y_star (independent)
y_star[,i] =  tau[(i-1),1] + y*tau[(i-1),2] + eps_y_star[,i]
}
}
list(X = X, M = M, m_star = m_star, y = y, y_star=y_star)
}
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(1,2)^.5
sigma_y_star = c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
X = runif(nobs) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star, sigma_y, sigma_y_star, nobs, X)
nobs = 1000   # number of observations
R = 2000; burnin = 1500
A_M=rep(100,2);
A_Y=c(100,100,10)
OutMeasurementCont = Measurement_Cont(Data = Data, BF = list(R = 5000, burnin = 3000, A_M = A_M, A_Y = A_Y))
mean(OutMeasurementCont$beta_1)
mean(OutMeasurementCont$beta_2)
mean(OutMeasurementCont$beta_3)
