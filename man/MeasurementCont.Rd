% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MeasurementCont.R
\name{MeasurementCont}
\alias{MeasurementCont}
\title{Sampler for Partial Mediation Model with Multiple Continuous Indicator for the Mediator and/or DV}
\usage{
MeasurementCont(Data, Prior, R, burnin)
}
\arguments{
\item{Data}{list(X, m_tilde, y_tilde)}

\item{Prior}{list(A_M,A_Y)}

\item{R}{number of MCMC iterations, default = 10000}
}
\value{
\describe{
\item{beta_1(R X 2)}{matrix of eq.1 coefficients' draws}
\item{beta_2(R X 3)}{matrix of eq.2 coefficients' draws}
\item{lambda (M_ind X 2 X R)}{array of mediator indicator coefficients' draws. Each slice is one draw, where rows represent the indicator equation and columns are the coefficients. All Slope coefficients as well as intercept of the first equation are fixed to 1 and 0 respectively.}
\item{ssq_m_star(R X M_ind)}{Matrix of mediator indicator equations' coefficients' error variance draws}
\item{ssq_y_star(R X Y_ind)}{Matrix of dependent variable indicator equations' coefficients' error variance draws}
\item{mu_draw}{vector of means of MCMC draws of the direct effect (used in BFSD to compute Bayes factor)}
\item{var_draw}{vector of means of MCMC draws of the direct effect (used in BFSD to compute Bayes factor)}
}
}
\description{
Estimates a partial mediation model with multiple categorical indicators for the mediator and the dependent variable using Hamiltonian Monte Carlo (HMC) with Stan
}
\details{
\subsection{Model}{

\tabular{ll}{
M = beta_0M + Xbeta_1 + U_M  \tab (eq.1) \cr
Y = beta_0Y + Mbeta_2 + Xbeta_3 + U_Y \tab (eq.2) \cr
}

Indicator equations:

\tabular{lcl}{
m*_1    \tab = \tab M + U_m*_1 \cr
˜m_1   \tab = \tab  OrdProbit(m*_1,C_m_1) \cr
m*_2     \tab = \tab lambda_01 + M + U_m*_2 \cr
˜m_2  \tab = \tab OrdProbit(m*_2,C_m_2) \cr
... \tab  \tab  \cr
m*_k   \tab =  \tab lambda_0k-1 + M + U_m*_k \cr
˜m_k   \tab = \tab OrdProbit(m*_k,C_m_k) \cr
y*_1   \tab = \tab M + U_y*_1 \cr
˜y_1  \tab = \tab  OrdProbit(y*_1,C_y_1) \cr
y*_2    \tab = \tab tau_01 + M + U_y*_2 \cr
˜y_2  \tab = \tab OrdProbit(y*_2,C_y_2) \cr
... \tab  \tab  \cr
y*_l   \tab =  \tab tau_0l-1 + M + U_y*_l \cr
˜y_l  \tab = \tab OrdProbit(y*_l,C_y_l) \cr
}
}

\subsection{Argument Details}{
}

\subsection{\code{Data = list(X, m_tilde, y_tilde)}}{

\describe{
\item{X(N x 1)}{treatment variable vector}
\item{m_tilde(N x M_ind)}{ediator indicators' matrix }
\item{y_tilde(N x Y_ind)}{dependent variable indicators' matrix}
}
}

\subsection{\code{Prior = list(A_M,A_Y)} \emph{[optional]}}{

\describe{
\item{A_M}{vector of coefficients' prior variances of eq.1, default = rep(100,2)}
\item{A_Y}{vector of coefficients' prior variances of eq.2, default = c(100,100,1)}
}
}
}
\examples{
library(rstan)
SimMeasurementCont = function( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star,
                              sigma_y, sigma_y_star, N, X) {

  m_star = matrix(double(N*m_ind),ncol = m_ind); y_star = matrix(double(N*y_ind),ncol = y_ind)
  eps_m_star = matrix(double(N*m_ind),ncol = m_ind); eps_y_star = matrix(double(N*y_ind),ncol = y_ind)
  eps_M = rnorm(N)*sigma_M # generate errors for M (independent)
  eps_Y = rnorm(N)*sigma_y # generate errors for y (independent)
  M = beta_1[1] + X*beta_1[2]  + eps_M # generate latent mediator M
  y = beta_2[1] +  M*beta_2[2] + X*beta_2[3] + eps_Y # generate dependent variable

  eps_m_star[,1]=rnorm(N)*sigma_m_star[1] # generate errors for m_star (independent)
  m_star[,1] =  M + eps_m_star[,1] # generate observed mediator indicators m_star
  if(m_ind>1){
    for(i in 2:(m_ind))   {
      eps_m_star[,i]=rnorm(N)*sigma_m_star[i] # generate errors for m_star (independent)
      m_star[,i] =  lambda[(i-1),1] + M*lambda[(i-1),2] + X*beta_2[-c(1,2)] + eps_m_star[,i]
    }
  }

  eps_y_star[,1]=rnorm(N)*sigma_y_star[1] # generate errors for y_star (independent)
  y_star[,1] =  y + eps_y_star[,1] # generate observed dependent variable indicators y_star
  if(y_ind>1){
    for(i in 2:(y_ind)){
      eps_y_star[,i]=rnorm(N)*sigma_y_star[i] # generate errors for y_star (independent)
      y_star[,i] =  tau[(i-1),1] + y*tau[(i-1),2] + eps_y_star[,i]
    }
  }
  list(X = X, M = M, m_star = m_star, y = y, y_star=y_star)
}
m_ind = 2; y_ind = 2;
sigma_M = 1^.5 # error std M
sigma_y = 1^.5 # error std y
sigma_m_star = c(.3,.5)^.5 #c(1,2)^.5
sigma_y_star = c(.5,.3)^.5  #c(2,1)^.5
beta_1 = c(1,1)
beta_2 = c(1,3,0)
lambda = matrix(c(1,1.5),ncol=2)
tau = matrix(c(1,2),ncol = 2)
k=length(beta_1)-1
nobs = 1000   # number of observations
X = runif(nobs) # generate random X from a uniform distribution
Data = SimMeasurementCont( beta_1, beta_2 , lambda, tau, m_ind, y_ind, sigma_M, sigma_m_star,
                          sigma_y, sigma_y_star, nobs, X)
R = 5000; burnin = 3000

A_M=rep(100,2);
A_Y=c(100,100,1)

#Estimation
out = MeasurementCont(Data = Data, Prior = list(A_M = A_M, A_Y = A_Y),R=5000, burnin = 3000)

#Results
colMeans(out$beta_1)
colMeans(out$beta_2)

BFMeasurementCont = exp(BFSD(post = out , prior = A_Y[3],burnin = 0))
}
